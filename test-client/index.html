<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MCP GraphQL Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root {
      --user-color: #3b82f6;
      --assistant-color: #14b8a6;
      --background: #f5f7fa;
      --bubble-bg: #fff;
      --bubble-shadow: 0 2px 4px rgba(0,0,0,0.06);
      --send-bg: #3b82f6;
      --send-hover: #2563eb;
      --tool-bg: #f7fdfc;
      --tool-border: #adeadd;
      --tool-title: #017461;
      --tool-input-bg: #e7f3f0;
      --tool-input-fg: #13504c;
      --tool-obs: #134b47;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      min-height: 100vh;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      background: var(--background);
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      width: 100vw;
    }
    .container {
      width: 100vw;
      max-width: 100vw;
      min-height: 100vh;
      height: 100vh;
      margin: 0;
      background: #fff;
      box-shadow: 0 2px 8px rgba(30,41,59,0.08);
      border-radius: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-sizing: border-box;
    }
    header {
      padding: 18px 24px;
      background: var(--user-color);
      color: #fff;
      font-size: 1.18em;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      gap: 10px;
    }
    #clear-history, #stream-toggle {
      background: rgba(255,255,255,0.12);
      border: none;
      color: #fff;
      border-radius: 6px;
      padding: 4px 12px;
      cursor: pointer;
      font-size: 0.97em;
      transition: background 0.17s;
    }
    #clear-history:hover, #stream-toggle:hover {
      background: rgba(255,255,255,0.24);
    }
    .chat-window {
      flex: 1 1 0;
      overflow-y: auto;
      padding: 22px 4vw 12px 4vw;
      background: var(--background);
      display: flex;
      flex-direction: column;
      width: 100%;
      min-width: 0;
      min-height: 0;
      box-sizing: border-box;
    }
    .msg-row {
      display: flex;
      align-items: flex-start;
      margin-bottom: 22px;
    }
    .msg-row.user { justify-content: flex-end; }
    .msg-row.assistant { justify-content: flex-start; }
    .msg-bubble {
      max-width: 90%;
      padding: 13px 15px;
      border-radius: 16px;
      box-shadow: var(--bubble-shadow);
      background: var(--bubble-bg);
      font-size: 1.08em;
      line-height: 1.52;
      overflow-wrap: break-word;
      word-break: break-all;
      white-space: pre-wrap;
      min-width: 0;
      box-sizing: border-box;
    }
    .msg-row.user .msg-bubble {
      background: var(--user-color);
      color: #fff;
      border-bottom-right-radius: 6px;
      align-self: flex-end;
      margin-left: 18px;
      margin-right: 0;
    }
    .msg-row.assistant .msg-bubble {
      background: var(--assistant-color);
      color: #fff;
      border-bottom-left-radius: 6px;
      align-self: flex-start;
      margin-right: 18px;
      margin-left: 0;
    }
    .msg-bubble code {
      background: rgba(0,0,0,0.12);
      padding: 1.5px 4px;
      border-radius: 4px;
      font-size: 0.97em;
      font-family: 'Fira Mono', 'Consolas', monospace;
      color: #0e0e0e;
      word-break: break-all;
      overflow-wrap: anywhere;
    }
    .msg-bubble pre {
      background: rgba(0,0,0,0.10);
      border-radius: 7px;
      padding: 10px 11px;
      overflow-x: auto;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 0.97em;
      color: #101010;
      white-space: pre;
      word-break: break-all;
      overflow-wrap: anywhere;
      max-width: 100%;
      box-sizing: border-box;
    }
    .msg-bubble a { color: #faffff; text-decoration: underline;}
    .msg-bubble h1, .msg-bubble h2, .msg-bubble h3 {
      font-size: 1.04em;
      margin: 0.5em 0 0.25em 0;
    }
    .typing-row {
      display: flex;
      align-items: flex-end;
      margin-bottom: 10px;
    }
    .typing {
      display: flex;
      align-items: center;
      background: var(--assistant-color);
      border-radius: 16px;
      padding: 11px 14px;
      min-width: 42px;
      min-height: 24px;
      box-shadow: var(--bubble-shadow);
      margin-right: 20px;
      margin-left: 0;
    }
    .dot {
      height: 9px; width: 9px;
      margin-right: 4px;
      background: #fff;
      border-radius: 50%;
      animation: bounce 1.2s infinite both;
      opacity: 0.80;
    }
    .dot:nth-child(2) { animation-delay: 0.15s; }
    .dot:nth-child(3) { animation-delay: 0.3s; }
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0.8);}
      40% { transform: scale(1.24);}
    }
    .input-area {
      display: flex;
      align-items: center;
      padding: 13px 14px 13px 18px;
      background: #f4f7fb;
      border-top: 1px solid #eff2f7;
      width: 100%;
      flex-shrink: 0;
      box-sizing: border-box;
    }
    #input {
      flex: 1;
      border: none;
      border-radius: 6px;
      padding: 10px 14px;
      font-size: 1.06em;
      background: #fff;
      box-shadow: 0 1.5px 8px rgba(30,41,59,0.04);
      margin-right: 10px;
      min-width: 0;
    }
    #input:focus { outline: none; box-shadow: 0 2px 16px rgba(30,41,59,0.09); }
    #send {
      background: var(--send-bg);
      color: #fff;
      font-size: 1.1em;
      font-weight: 500;
      border: none;
      border-radius: 7px;
      padding: 9px 20px;
      cursor: pointer;
      transition: background .18s;
      box-shadow: 0 2px 5px rgba(59,130,246,0.04);
    }
    #send:disabled { opacity: 0.50; cursor: not-allowed;}
    #send:hover:not(:disabled) { background: var(--send-hover); }
    /* --- Tool Call Styling (improved) --- */
    .tool-calls-wrapper {
      margin: 8px 0 0 0;
      padding: 0;
      max-width: 68vw;
      width: fit-content;
      min-width: 280px;
    }
    .tool-call {
      background: var(--tool-bg);
      border-left: 4px solid var(--tool-border);
      border-radius: 10px;
      margin: 16px 0 0 0;
      padding: 14px 18px 11px 16px;
      font-size: 0.99em;
      line-height: 1.38;
      box-shadow: 0 1.5px 6px rgba(0,128,64,0.04);
    }
    .tool-meta {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px 16px;
    }
    .tool-title {
      font-weight: bold;
      color: var(--tool-title);
      font-size: 1.05em;
      margin-right: 11px;
      letter-spacing: 0.02em;
    }
    .tool-input-label {
      color: #555;
      opacity: 0.95;
      font-size: 0.97em;
      font-weight: 500;
    }
    .tool-input {
      margin: 0 0 0 3px;
      background: var(--tool-input-bg);
      border-radius: 5px;
      padding: 3px 7px;
      font-family: 'Fira Mono', 'Consolas', monospace;
      color: var(--tool-input-fg);
      font-size: 0.99em;
      display: inline;
      border: none;
    }
    .obs-expand {
      margin-left: 14px;
      background: #ccf7f2;
      border: none;
      border-radius: 5px;
      padding: 2.5px 13px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      color: #098f7b;
      transition: background .18s;
      box-shadow: 0 1px 2px rgba(0,128,64,0.05);
    }
    .obs-expand:hover { background: #b5efe9; }
    .observation {
      margin-top: 7px;
      background: #fff;
      border: 1px dashed var(--tool-border);
      border-radius: 7px;
      padding: 8px 13px;
      color: var(--tool-obs);
      font-size: 0.97em;
      line-height: 1.46;
      font-family: 'Fira Mono', 'Consolas', monospace;
      white-space: pre-wrap;
      overflow-x: auto;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <span>MCP GraphQL Chat</span>
      <button id="stream-toggle" type="button" title="Toggle streaming mode">
        üîÑ Streaming: <span id="stream-toggle-label">Off</span>
      </button>
      <button id="clear-history" title="Clear chat history">Clear history</button>
    </header>
    <div class="chat-window" id="chat-window"></div>
    <form class="input-area" autocomplete="off" id="chat-form">
      <input id="input" type="text" placeholder="Type your question and hit Enter..." autocomplete="off" />
      <button type="submit" id="send">Send</button>
    </form>
  </div>
  <script>
    const chatWindow = document.getElementById('chat-window');
    const input = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const chatForm = document.getElementById('chat-form');
    const clearBtn = document.getElementById('clear-history');
    const streamToggle = document.getElementById('stream-toggle');
    const streamToggleLabel = document.getElementById('stream-toggle-label');
    const LS_KEY = "mcpgraphql_openai_chat";
    let streamingMode = false;
    let isAwaiting = false;

    // Stream toggle logic
    streamToggle.addEventListener('click', () => {
      streamingMode = !streamingMode;
      streamToggleLabel.textContent = streamingMode ? "On" : "Off";
    });

    // ----- HISTORY UTILS -----
    function getHistory() {
      try {
        return JSON.parse(localStorage.getItem(LS_KEY) || "[]") || [];
      } catch (e) { return []; }
    }
    function setHistory(history) {
      localStorage.setItem(LS_KEY, JSON.stringify(history));
    }
    function clearHistory() {
      localStorage.removeItem(LS_KEY);
    }

    // ----- RENDERING -----
    function renderMarkdown(text) {
      return marked.parse(text ?? "", {sanitize: true});
    }

    // Tool Call Rendering
    function renderToolCalls(tool_calls) {
      if (!Array.isArray(tool_calls) || !tool_calls.length) return '';
      return tool_calls.map((t, i) => `
       <div class="tool-call">
  <div class="tool-meta" style="display: flex; align-items: flex-start; gap: 1em;">
    <span class="tool-title" style="font-weight: bold;">${escapeHtml(t.tool)}</span>
    <span class="tool-input-label" style="min-width:60px;">Input:</span>
    <pre class="tool-input" style="margin:0; padding:2px 6px; min-width:100px; max-width:350px; overflow-x:auto; white-space: pre; background:#f9f9f9; border-radius:2px; border:1px solid #eee; flex:1 1 auto; display:inline-block; vertical-align:middle;">
${escapeHtml(typeof t.tool_input === "string" ? t.tool_input : JSON.stringify(t.tool_input))}
    </pre>
    <button class="obs-expand" data-i="${i}" style="margin-left:8px;">Show Observation</button>
  </div>
  <pre class="observation" style="display:none;">${escapeHtml(t.observation || "")}</pre>
</div>
      `).join('');
    }

    function escapeHtml(str) {
      if (typeof str !== "string") return "";
      return str.replace(/[&<>'"]/g, ch => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": '&#39;', '"': '&quot;'
      }[ch]));
    }

    function renderHistory() {
      chatWindow.innerHTML = '';
      getHistory().forEach(msg => appendMsg(msg.role, msg.content, false));
      if (isAwaiting) showTyping();
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // ------- APPEND/UPDATE MSGS -------
    function appendMsg(role, text, save = true) {
      let row = document.createElement('div');
      row.className = "msg-row " + (role === "assistant" ? "assistant" : "user");
      let col = document.createElement('div');
      col.style.display = "flex";
      col.style.flexDirection = "column";
      col.style.alignItems = "flex-start";
      col.style.width = "100%";
      let bubble = document.createElement('div');
      bubble.className = "msg-bubble";
      let message, tool_calls;
      try {
        message = JSON.parse(text);
        if (typeof message === "object" && message.result !== undefined) {
          bubble.innerHTML = renderMarkdown(message.result ?? "");
          tool_calls = message.tool_calls;
        } else {
          bubble.innerHTML = renderMarkdown(text);
        }
      } catch {
        bubble.innerHTML = renderMarkdown(text);
      }
      if (role === "assistant" && Array.isArray(tool_calls) && tool_calls.length) {
        const toolsDiv = document.createElement("div");
        toolsDiv.className = "tool-calls-wrapper";
        toolsDiv.innerHTML = renderToolCalls(tool_calls);
        col.appendChild(toolsDiv);
      }
      col.appendChild(bubble);
      row.appendChild(col);
      chatWindow.appendChild(row);
      if (save) {
        let h = getHistory();
        h.push({role, content: text});
        setHistory(h);
      }
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // ----- Expand/collapse for observations -----
    chatWindow.addEventListener('click', function(e) {
      if (e.target.matches('.obs-expand')) {
        const toolCall = e.target.closest('.tool-call');
        const obs = toolCall.querySelector('.observation');
        if (obs.style.display === "none") {
          obs.style.display = "block";
          e.target.textContent = "Hide Observation";
        } else {
          obs.style.display = "none";
          e.target.textContent = "Show Observation";
        }
      }
    });

    // ----- TYPING -----
    let typingNode = null;
    function showTyping() {
      removeTyping();
      let row = document.createElement('div');
      row.className = "typing-row";
      let typingBubble = document.createElement('div');
      typingBubble.className = "typing";
      for (let i = 0; i < 3; ++i) {
        let dot = document.createElement('div');
        dot.className = 'dot';
        typingBubble.appendChild(dot);
      }
      row.appendChild(typingBubble);
      chatWindow.appendChild(row);
      chatWindow.scrollTop = chatWindow.scrollHeight;
      typingNode = row;
    }
    function removeTyping() {
      if (typingNode && typingNode.parentNode) {
        typingNode.parentNode.removeChild(typingNode);
        typingNode = null;
      } else {
        let el = chatWindow.querySelector('.typing-row');
        if (el && el.parentNode) el.parentNode.removeChild(el);
        typingNode = null;
      }
    }

    // ======== SEND MESSAGE & LIVE UPDATE LOGIC ========
    async function sendMsg(event) {
      if (event) event.preventDefault();
      const text = input.value.trim();
      if (!text || isAwaiting) return;
      isAwaiting = true;
      input.value = '';
      input.disabled = true;
      sendBtn.disabled = true;
      appendMsg("user", text);
      showTyping();

      let payload = {
        question: text,
        history: getHistory(),
      };

      let toolCalls = [];
      let finalResult = '';
      let receivedAny = false;
      let assistantMsgIdx = null;
      // ... previous code ...

function updateAssistantMsg() {
  removeTyping();
  if (assistantMsgIdx === null) {
    appendMsg(
      "assistant",
      JSON.stringify({ result: finalResult, tool_calls: toolCalls })
    );
    assistantMsgIdx = getHistory().length - 1;
  } else {
    let msgRows = chatWindow.getElementsByClassName("msg-row assistant");
    if (!msgRows.length) return;
    let lastMsg = msgRows[msgRows.length - 1];
    let bubble = lastMsg.querySelector(".msg-bubble");
    bubble.innerHTML = renderMarkdown(finalResult ?? "");

    let existingTools = lastMsg.querySelector(".tool-calls-wrapper");
    if (toolCalls.length > 0) {
      if (existingTools) {
        existingTools.innerHTML = renderToolCalls(toolCalls);
      } else {
        let toolsDiv = document.createElement("div");
        toolsDiv.className = "tool-calls-wrapper";
        toolsDiv.innerHTML = renderToolCalls(toolCalls);
        lastMsg.insertBefore(toolsDiv, bubble);
      }
    } else {
      if (existingTools) existingTools.remove();
    }

    let h = getHistory();
    h[assistantMsgIdx] = {
      role: "assistant",
      content: JSON.stringify({ result: finalResult, tool_calls: toolCalls })
    };
    setHistory(h);
  }
  chatWindow.scrollTop = chatWindow.scrollHeight;
}

try {
  if (streamingMode) {
    // --- STREAMING MODE ---
    const res = await fetch('/ask?stream=true', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.body) throw new Error('No stream supported.');
    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let parts = buffer.split('\n\n');
      buffer = parts.pop();
      for (const part of parts) {
        const line = part.trim();
        if (line.startsWith('data:')) {
          try {
            const msg = JSON.parse(line.slice(5).trim());
            receivedAny = true;
            if (msg.type === "tool_call") {
              toolCalls.push({
                tool: msg.tool,
                tool_input: msg.tool_input,
                observation: msg.observation
              });
              updateAssistantMsg();
            } else if (msg.type === "result") {
              finalResult = msg.result;
              updateAssistantMsg();
            }
          } catch (e) { }
        }
      }
    }
  } else {
    // --- NON-STREAMING MODE ---
    const res = await fetch('/ask?stream=false', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const data = await res.json();
    finalResult = data.result || '';
    if (Array.isArray(data.tool_calls)) {
      toolCalls = data.tool_calls;
    } else {
      toolCalls = [];
    }
    updateAssistantMsg();
    receivedAny = true;
  }
  removeTyping();
  if (!receivedAny) appendMsg("assistant", "‚ö†Ô∏è No response");
} catch (e) {
  removeTyping();
  appendMsg("assistant", "‚ö†Ô∏è Error: " + e.message);
}
isAwaiting = false;
input.disabled = false;
sendBtn.disabled = false;
input.focus();
}

// ======= EVENT BINDINGS =======
chatForm.addEventListener('submit', sendMsg);
input.addEventListener('keydown', function (e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMsg();
  }
});

// Clear and reload on click
clearBtn.addEventListener('click', function () {
  if (confirm("Clear entire chat history?")) {
    clearHistory();
    renderHistory();
    input.focus();
  }
});

// INITIALIZE
renderHistory();
input.focus();
  </script>
</body>
</html> 